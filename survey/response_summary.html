<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Frequency Plots for Section 1 and Section 2</title>
        <!-- Chart.js CDN -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
        <!-- Bootstrap CDN for styling -->
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
        <style>
            .section-container {
                margin-bottom: 20px;
                border: 1px solid #ddd;
                border-radius: 8px;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
                padding: 50px;
            }
            .container-top { /* contains section title and common legend */
            }
            .top-title { /* the title */
                font-size: 20px;
                font-weight: bold;
                margin: 0 0 10px 0;
                text-align: center;
            }
            .top-legend {
                display: flex;
                justify-content: center;
                margin-bottom: 20px;
            }
            .top-legend ul {
                list-style: none;
                padding: 0;
            }
            .top-legend li {
                display: inline-block;
                margin-right: 10px;
                cursor: pointer;
                font-size: 10px;
            }
            .top-legend span {
                display: inline-block;
                width: 10px;
                height: 10px;
                margin-right: 5px;
            }
            .section-bottom { /* contains the plots */
                height: 300px;
                display: flex;
                flex-wrap: wrap;
                justify-content: space-evenly;
            }
            .bottom-plot {
                padding: 10px;
            }
            .bottom-text {
                font-size: 10px;
                margin: 0 0 10px 0;
                text-align: left;
            }
        </style>
    </head>
    <body>
        <div id="main-container" width="400" height="400"></div>
        <script>

            // Your Google Spreadsheet ID
            const spreadsheetId = '17c7_UNC2QgLCaqCD3-pmIW5GMVqTX__J7yiRlTZ1f3o';
            const range = 'Form Responses 1'; // Specify the sheet name

            // Your Google API Key
            const apiKey = 'AIzaSyD1BzLD1l55zIdFRwBnU6VeEYf6KaO4Yds';

            // Function to fetch data from Google Sheets
            async function fetchData() {
                try {
                    const url = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${range}?key=${apiKey}`;
                    const response = await fetch(url);
                    if (!response.ok) {
                        const errorResponse = await response.json();
                        throw new Error(`Error fetching data: ${errorResponse.error.message}`);
                    }
                    const data = await response.json();
                    if (!data || !data.values) {
                        throw new Error('No data found in the response');
                    }
                    return data.values;
                } catch (error) {
                    console.error('Error fetching data:', error);
                    return [];
                }
            }

            const myBackgroundColor = [
              'rgba(255, 99, 132, 0.5)',
              'rgba(54, 162, 235, 0.5)',
              'rgba(255, 206, 86, 0.5)',
              'rgba(75, 192, 192, 0.5)',
              'rgba(153, 102, 255, 0.5)',
              'rgba(255, 159, 64, 0.5)',
              'rgba(255, 99, 132, 0.5)',
              'rgba(54, 162, 235, 0.5)',
              'rgba(255, 206, 86, 0.5)',
              'rgba(75, 192, 192, 0.5)',
              'rgba(153, 102, 255, 0.5)',
              'rgba(255, 159, 64, 0.5)', 
            ];

            const myBorderColor = [
             'rgba(255, 99, 132, 1)',
             'rgba(54, 162, 235, 1)',
             'rgba(255, 206, 86, 1)',
             'rgba(75, 192, 192, 1)',
             'rgba(153, 102, 255, 1)',
             'rgba(255, 159, 64, 1)',
             'rgba(255, 99, 132, 1)',
             'rgba(54, 162, 235, 1)',
             'rgba(255, 206, 86, 1)',
             'rgba(75, 192, 192, 1)',
             'rgba(153, 102, 255, 1)',
             'rgba(255, 159, 64, 1)', 
            ];

            function getFormattedPair(value, dataset) {
              if (value !== undefined) {
                let total = dataset.data.reduce((acc, val) =>acc + val, 0);
                let percentage = parseFloat(((value/total)*100).toFixed(1));
                return `${value}\n(${percentage}%)`
              } else { 
                return '0\n(0%)';
              }
            }

            // Function to plot a bar chart
            function plotChartCanvas(ctx, xLabels, yValues, chartTitle, chartType='bar') {
              // create the config
              config = {
                type: chartType,
                data: {
                  labels: xLabels,
                  datasets: [{
                    label: chartTitle,
                    data: yValues,
                    backgroundColor: myBackgroundColor,
                    borderColor: myBorderColor, 
                    borderWidth: 1
                  }]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: {
                      display: false,
                      position: 'top',
                      labels: {
                        boxWidth: 10,
                      },
                    },
                    tooltip: {
                      callbacks: {
                        label: function(context){
                            return getFormattedPair(context.raw, context.dataset);
                        },
                      },
                    },
                    title: {
                      display: true,
                      text: chartTitle,
                      font: {
                        size: 16,
                        weight: 'bold',
                      },
                    },
                    datalabels: {
                      color: '#000',
                      anchor: 'end',
                      align: 'start',
                      formatter: function(value, context) {
                        return getFormattedPair(value, context.chart.data.datasets[0]);
                      },
                      font: {
                        size: 8,
                      },
                    },
                  },
                  // scales: {
                  //   x: {
                  //     ticks: {
                  //       display: false,
                  //     },
                  //     grid: {
                  //       display: false,
                  //     },
                  //   },
                  // },
                }
              };

              // Ensure datalabels plugin is loaded and applied
              Chart.register(ChartDataLabels);
              new Chart(ctx, config);
            }

            function makeFirstUpper(value) {
                return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
            }

            function validateValue(value) {
              if (typeof value !== 'string') {
                return [value];
              }
              if (value.includes('INR') || value.includes('Bothered') || value.slice(0, 3) === 'No,') {
                return [value];
              }
              if (value === 'Na' || value === 'na' || value === 'N/a' || value === 'n/a' || value === 'N/A' || value === 'NA' || value === 'None' || value === 'none' || value === 'NONE') {
                return [''];
              }
              
              // for all other reasons
              output = [];
              value.split(', ').forEach(val => {
                output.push(makeFirstUpper(val));
              });
              return output;
            }

            // transform the data into list of column frequency dictionaries
            function columnValueFrequencies(data) {
              let numColumns = data[0].length;
              let frequencyList = [];
              // initialize
              for (let col=0; col < numColumns; col++) {
                frequencyList.push({});
              }
              // populate the dictionary
              for (let row of data) {
                for (let col = 0; col < numColumns; col++) {
                  let valArr = validateValue(row[col]);
                  valArr.forEach(val => {
                    if (val !== undefined && val !== null && val !== "")
                    {
                      if (col === 0) { // for timestamp column
                          val = val.split(' ')[0];
                      }
                      if (frequencyList[col][val]) {
                        frequencyList[col][val] += 1;
                      } else {
                        frequencyList[col][val] = 1;
                      }
                    }
                  });
                }
              }
              // sort every dict for keys
              for(let i = 0; i < frequencyList.length; i++) {
                  frequencyList[i] = Object.fromEntries(Object.entries(frequencyList[i]).sort(([keyA], [keyB]) => keyA.localeCompare(keyB)));
              }
              return frequencyList;
            }

            /*
            // make a shared dataset for plotting
            function makeSharedDataset(commonLabelsArray, dataArrayList, dataNameList) {
                datasetDictList = [];
                for (let i=0; i < dataArrayList.length; i++)
                {
                  let datasetDict = {
                    label: dataNameList[i],
                    data: dataArrayList[i],
                    backgroundColor: myBackgroundColor,
                    borderColor: myBorderColor,
                    borderWidth: 1,
                  };
                  datasetDictList.push(datasetDict);
                }
                let sharedData = {
                  labels: commonLabelsArray,
                  datasets: datasetDictList,
                };
                return sharedData;
            }

            // function to make data dictionary for plotting
            function makeDataDictForPlot(xLabels, yValues, datasetName) {
              let datasetDict = {
                labels: xLabels,
                datasets: [{
                  label: datasetName,
                  data: yValues,
                  backgroundColor: myBackgroundColor,
                  borderColor: myBorderColor,
                  borderWidth: 1,
                }],
              };
              return datasetDict;
            }
            */

            
            function makeNewElement(elementType, className=null) {
              const newElement = document.createElement(elementType);
              if (className !== null) {
                newElement.classList.add(className);
              }
              return newElement;
            }

            
            function prepareCanvas(numPlots) {
               const plot = makeNewElement('div', 'bottom-plot');
               plot.style.flex = `1 0 ${100 / numPlots}%`;
               plot.style.maxWidth = `${100 / numPlots}%`;
               const canvas = makeNewElement('canvas');
               plot.appendChild(canvas);
               return plot;
            }


            function newSectionText(sectionName, textDict) {
              // make section container
              const container = document.getElementById('main-container');
              const sectionContainer = makeNewElement('div', 'section-container');
              container.appendChild(sectionContainer);

              // make top
              const sectionTop = makeNewElement('div', 'container-top');
              sectionContainer.appendChild(sectionTop);
              const topTitle = makeNewElement('div', 'top-title');
              let numResponses = Object.values(textDict).reduce((acc, curr) => acc+curr, 0);
              topTitle.innerHTML = `${sectionName}<br>(${numResponses} responses)`;
              sectionTop.appendChild(topTitle);

              // make bottom
              const sectionBottom = makeNewElement('div', 'bottom-text');
              sectionContainer.appendChild(sectionBottom);
              const ul = makeNewElement('ul');
              sectionBottom.appendChild(ul);

              Object.keys(textDict).forEach(key => {
                const li = makeNewElement('li');
                ul.appendChild(li);
                li.textContent = `${key} (${textDict[key]})`;
              });
            }


            // plot section
            function newSectionPlot(sectionName, numResponses, xLabels, yValuesArr, datasetNameArr, chartType='pie') {
              // make section container
              const container = document.getElementById('main-container');
              const sectionContainer = makeNewElement('div', 'section-container');
              container.appendChild(sectionContainer);

              // make top
              const sectionTop = makeNewElement('div', 'container-top');
              sectionContainer.appendChild(sectionTop);
              const topTitle = makeNewElement('div', 'top-title');
              if (numResponses >= 0) {
                topTitle.innerHTML = `${sectionName}<br>(${numResponses} responses)`;
              } else {
                topTitle.innerHTML = sectionName;
              }
              sectionTop.appendChild(topTitle);

              // make bottom
              const sectionBottom = makeNewElement('div', 'section-bottom');
              sectionContainer.appendChild(sectionBottom);

              // loop over various values to make the plot
              let numPlots = yValuesArr.length;
              yValuesArr.forEach((yValues, index) => {
                const plot = prepareCanvas(numPlots);
                sectionBottom.appendChild(plot);
                const ctx = plot.children[0].getContext('2d');
                plotChartCanvas(ctx, xLabels, yValues, datasetNameArr[index], chartType);
              });


              // make common legend if needed
              if (true) {
                const topLegend = makeNewElement('div', 'top-legend');
                sectionTop.appendChild(topLegend);
                // Create the combined legend HTML from the shared data
                var combinedLegendHTML = '<ul>';
                xLabels.forEach(function(label, index) {
                  var colorIndex = index % myBackgroundColor.length;
                  combinedLegendHTML += `
                    <li>
                      <span style="background-color: ${myBackgroundColor[colorIndex]}; border: 1px solid ${myBorderColor[colorIndex]}"></span>${label}
                    <\li>
                  `;
                });
                combinedLegendHTML += '</ul>';
                topLegend.innerHTML = combinedLegendHTML;
              }

            }


            function getUniqueHeads(dictionaryArr) {
              uniqueHeads = new Set();
              dictionaryArr.forEach(dict => {
                Object.keys(dict).forEach(val => {
                  uniqueHeads.add(val);
                });
              });
              uniqueHeads = Array.from(uniqueHeads).sort();
              // console.log('Heads', uniqueHeads);
              return uniqueHeads;
            }


            function makeInsideOut(heads, dictionaryArr) {
              let headData = [];
              uniqueHeads.forEach(val => {
                let outRow = []
                dictionaryArr.forEach(dict => {
                  if (dict[val]) {
                    outRow.push(dict[val]);
                  } else {
                    outRow.push(0);
                  }
                });
                headData.push(outRow);
              });
              return headData;
            }


            // Function to swap first and last keys along with their values
            function swapItems(dict, firstIndex, secondIndex) {
              // Extract keys and values from the original dictionary
              let N = Object.keys(dict).length;
              let newDict = {};
              for(let i=0; i<N; i++) {
                if (i !== firstIndex && i !== secondIndex) {
                  newDict[Object.keys(dict)[i]] = Object.values(dict)[i];
                }
                else {
                  if (i === firstIndex) {
                    newDict[Object.keys(dict)[secondIndex]] = Object.values(dict)[secondIndex];
                  } else {
                    newDict[Object.keys(dict)[firstIndex]] = Object.values(dict)[firstIndex];
                  }
                }
              }
              return newDict;
            }


            // Fetch data and create charts
            fetchData().then(tableData => {
              if (!tableData || tableData.length === 0) {
                  console.error('No data available');
                  return;
              }

              const headers = tableData[0]; // header row
              const frequencyDict = columnValueFrequencies(tableData.slice(1));
              const numResponses  = Object.values(frequencyDict[0]).reduce((acc, curr) => acc + curr, 0); // sum of all values of the 1st dictionary
              // console.log('main', frequencyDict);

              // section 1
              newSectionPlot(headers[0], numResponses, Object.keys(frequencyDict[0]), [Object.values(frequencyDict[0])], ["Date"], 'line');

              // section 2 (age)
              newSectionPlot(headers[1], numResponses, Object.keys(frequencyDict[1]), [Object.values(frequencyDict[1])], [headers[1]], 'bar');

              // section 3 (cols 3-11)
              let freqTitle = headers[2].substring(0, headers[2].indexOf('['));
              let uniqueHeads = getUniqueHeads(frequencyDict.slice(2, 11));
              let freqKeys = headers.slice(2, 11).map(val => val.substring(val.indexOf('[') + 1, val.indexOf(']')));
              let freqList  = makeInsideOut(uniqueHeads, frequencyDict.slice(2, 11));
              newSectionPlot(freqTitle, numResponses, freqKeys, freqList, uniqueHeads, 'pie');

              // section 4 (cols 12-20)
              freqTitle = headers[11].substring(0, headers[11].indexOf('['));
              uniqueHeads = getUniqueHeads(frequencyDict.slice(11, 20));
              freqList  = makeInsideOut(uniqueHeads, frequencyDict.slice(11, 20));
              newSectionPlot(freqTitle, numResponses, freqKeys, freqList, uniqueHeads, 'pie');

              // section 5 (other reasons) ...list by frequency of occurance row 21
              // newSectionPlot(headers[20], numResponses, Object.keys(frequencyDict[20]), [Object.values(frequencyDict[20])], [headers[20]], 'pie');
              newSectionText(headers[20], frequencyDict[20]);

              // section 6 (how do you overcome the problems) // row 22
              newSectionPlot(headers[21], numResponses, Object.keys(frequencyDict[21]), [Object.values(frequencyDict[21])], [headers[21]], 'pie'); // Need to split the combinations
              
              // section 7 (are you satisfied) // row 23
              newSectionPlot(headers[22], numResponses, Object.keys(frequencyDict[22]), [Object.values(frequencyDict[22])], [headers[22]], 'pie'); 

              // section 8 (desired solution) // row 24
              newSectionPlot(headers[23], numResponses, Object.keys(frequencyDict[23]), [Object.values(frequencyDict[23])], [headers[23]], 'pie'); 
              
              // section 9 (cost) // row 25
              costDict = swapItems(frequencyDict[24], 0, Object.keys(frequencyDict[24]).length-1);
              costDict = swapItems(costDict, 3, 4);
              costDict = swapItems(costDict, 2, 3);
              newSectionPlot(headers[24], numResponses, Object.keys(costDict), [Object.values(costDict)], [headers[24]], 'bar'); 

              // section 10 (comments) // row 26 ... need to display the text
              newSectionText("Comments/Suggestions/Contact of people you may know", frequencyDict[25]);
              
              // section 11 (available for feedback) // row 27
              newSectionPlot(headers[26], numResponses, Object.keys(frequencyDict[26]), [Object.values(frequencyDict[26])], [headers[26]], 'bar'); 

            });

        </script>
    </body>
</html>

