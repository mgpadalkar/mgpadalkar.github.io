<!DOCTYPE html>
<html>
<head>
    <title>Google Sheets Charts</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <style>
        .chart-container {
            width: 90%; /* Adjust width to fit better within the page */
            height: 450px;
            margin: 20px auto; /* Center align and space out the charts */
            padding: 50px;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            float: left; /* Float the elements to make them display in a row */
        }
        .chart-container h2 {
            font-size: 18px;
            margin: 0 0 10px 0;
            text-align: center;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .response-section {
            text-align: center;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>Charts from Google Sheets</h1>

    <div class="response-section">
        <h2>Number of Responses <span id="responseCount"></span></h2>
    </div>

    <div id="chartsContainer" class="chart-row"></div>

    <script>
        // Your Google Spreadsheet ID
        const spreadsheetId = '17c7_UNC2QgLCaqCD3-pmIW5GMVqTX__J7yiRlTZ1f3o';
        const range = 'Form Responses 1'; // Specify the sheet name

        // Your Google API Key
        const apiKey = 'AIzaSyD1BzLD1l55zIdFRwBnU6VeEYf6KaO4Yds';

        // Function to fetch data from Google Sheets
        async function fetchData() {
            try {
                const url = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${range}?key=${apiKey}`;
                const response = await fetch(url);
                if (!response.ok) {
                    const errorResponse = await response.json();
                    throw new Error(`Error fetching data: ${errorResponse.error.message}`);
                }
                const data = await response.json();
                if (!data || !data.values) {
                    throw new Error('No data found in the response');
                }
                return data.values;
            } catch (error) {
                console.error('Error fetching data:', error);
                return [];
            }
        }

        // Define an array of colors for the bar charts
        const barColors = [
            'rgba(255, 99, 132, 0.2)',
            'rgba(54, 162, 235, 0.2)',
            'rgba(255, 206, 86, 0.2)',
            'rgba(75, 192, 192, 0.2)',
            'rgba(153, 102, 255, 0.2)',
            'rgba(255, 159, 64, 0.2)',
            'rgba(199, 199, 199, 0.2)',
            'rgba(83, 102, 255, 0.2)',
            'rgba(255, 255, 102, 0.2)',
            'rgba(175, 192, 192, 0.2)'
        ];
        const borderColors = [
            'rgba(255, 99, 132, 1)',
            'rgba(54, 162, 235, 1)',
            'rgba(255, 206, 86, 1)',
            'rgba(75, 192, 192, 1)',
            'rgba(153, 102, 255, 1)',
            'rgba(255, 159, 64, 1)',
            'rgba(199, 199, 199, 1)',
            'rgba(83, 102, 255, 1)',
            'rgba(255, 255, 102, 1)',
            'rgba(175, 192, 192, 1)'
        ];

        // Function to create chart
        function createChart(sectionName, labels, values, canvasId, chartType = 'pie') {
            const ctx = document.getElementById(canvasId).getContext('2d');
            const config = {
                type: chartType,
                data: {
                    labels: labels,
                    datasets: [{
                        label: sectionName,
                        data: values,
                        backgroundColor: chartType === 'bar' ? barColors.slice(0, labels.length) : [
                            'rgba(255, 99, 132, 0.2)',
                            'rgba(54, 162, 235, 0.2)',
                            'rgba(255, 206, 86, 0.2)',
                            'rgba(75, 192, 192, 0.2)',
                            'rgba(153, 102, 255, 0.2)',
                            'rgba(255, 159, 64, 0.2)',
                            'rgba(255, 99, 132, 0.2)',
                            'rgba(54, 162, 235, 0.2)',
                            'rgba(255, 206, 86, 0.2)',
                            'rgba(75, 192, 192, 0.2)',
                            'rgba(153, 102, 255, 0.2)',
                            'rgba(255, 159, 64, 0.2)'
                        ],
                        borderColor: chartType === 'bar' ? borderColors.slice(0, labels.length) : [
                            'rgba(255, 99, 132, 1)',
                            'rgba(54, 162, 235, 1)',
                            'rgba(255, 206, 86, 1)',
                            'rgba(75, 192, 192, 1)',
                            'rgba(153, 102, 255, 1)',
                            'rgba(255, 159, 64, 1)',
                            'rgba(255, 99, 132, 1)',
                            'rgba(54, 162, 235, 1)',
                            'rgba(255, 206, 86, 1)',
                            'rgba(75, 192, 192, 1)',
                            'rgba(153, 102, 255, 1)',
                            'rgba(255, 159, 64, 1)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    if (chartType === 'bar') {
                                        return `${context.label}: ${context.raw}`;
                                    } else {
                                        let label = '';
                                        if (context.parsed !== null) {
                                            label += context.parsed;
                                        }
                                        if (context.dataset) {
                                            const total = context.dataset.data.reduce((acc, val) => acc + val, 0);
                                            const currentValue = context.parsed;
                                            const percentage = parseFloat(((currentValue / total) * 100).toFixed(1));
                                            label += ` (${percentage}%)`;
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        legend: {
                            display: chartType !== 'bar', // Display legends for non-bar charts only
                            position: 'right',
                            labels: {
                                boxWidth: 10,
                            }
                        },
                        datalabels: {
                            color: '#000',
                            font: {
                                weight: 'bold'
                            },
                            formatter: function(value, ctx) {
                                const dataset = ctx.chart.data.datasets[0];
                                const total = dataset.data.reduce((acc, val) => acc + val, 0);
                                const percentage = parseFloat(((value / total) * 100).toFixed(1));
                                return `${value} (${percentage}%)`;
                            },
                            anchor: 'end', // Position of the label relative to the anchor point
                            align: 'start' // Alignment of text relative to the anchor point
                        }
                    }
                }
            };

            // Ensure datalabels plugin is loaded and applied
            Chart.register(ChartDataLabels);

            new Chart(ctx, config);
        }

        // Fetch data and create charts
        fetchData().then(data => {
            if (!data || data.length === 0) {
                console.error('No data available.');
                return;
            }

            const headers = data[0]; // Assuming the first row contains headers
            const rows = data.slice(1); // Skip header row

            // Count the number of timestamps (responses)
            const responseCount = rows.length;

            // Display the response count
            document.getElementById('responseCount').textContent = `= ${responseCount}`;

            // Process data for histogram
            const dateCounts = rows.reduce((acc, row) => {
                const dateTime = row[0]; // First column contains timestamps
                const date = dateTime.split(' ')[0]; // Extract the date part (DD/MM/YYYY)
                if (date) {
                    if (acc[date]) {
                        acc[date] += 1;
                    } else {
                        acc[date] = 1;
                    }
                }
                return acc;
            }, {});

            console.log('Date counts:', dateCounts);

            // Process date data into labels and values for histogram
            const dateLabels = Object.keys(dateCounts);
            const dateValues = Object.values(dateCounts);

            // Create a canvas element for the date histogram
            const dateCanvasId = 'dateHistogram';
            const dateSection = document.createElement('section');
            dateSection.classList.add('chart-container');
            dateSection.innerHTML = `<h2>Date of Entry Histogram</h2><canvas id="${dateCanvasId}"></canvas>`;
            document.getElementById('chartsContainer').appendChild(dateSection);

            // Create date histogram chart
            createChart('Date of Entry', dateLabels, dateValues, dateCanvasId, 'bar');

            // Iterate over each column (excluding the first one, which contains timestamps)
            headers.forEach((header, colIndex) => {
                if (colIndex === 0) return; // Skip the first column (timestamps)

                // Aggregate data based on unique values in the current column
                const aggregatedData = rows.reduce((acc, row) => {
                    const value = row[colIndex]; // Values from the current column
                    if (value) {
                        if (acc[value]) {
                            acc[value] += 1;
                        } else {
                            acc[value] = 1;
                        }
                    }
                    return acc;
                }, {});

                // Process data into labels and values
                const labels = Object.keys(aggregatedData);
                const values = Object.values(aggregatedData);

                console.log(`Data for column ${header}:`, aggregatedData);

                // Create a canvas element for the chart
                const canvasId = `chart${colIndex}`;
                const section = document.createElement('section');
                section.classList.add('chart-container');
                section.innerHTML = `<h2>${header}</h2><canvas id="${canvasId}"></canvas>`;
                document.getElementById('chartsContainer').appendChild(section);

                // Create chart
                createChart(header, labels, values, canvasId);
            });
            
            // Identify unique elements in columns 3-11 (excluding the first row)
            const uniqueElements = new Set();
            for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                for (let colIndex = 2; colIndex < 11; colIndex++) {
                    const value = rows[rowIndex][colIndex];
                    if (value) {
                        uniqueElements.add(value);
                    }
                }
            }

            // Convert the Set to an array and sort it
            const sortedUniqueElements = Array.from(uniqueElements).sort();
            console.log('Unique elements in columns 3-11 (sorted):', sortedUniqueElements);

            // Create sub-histograms for each unique element
            sortedUniqueElements.forEach(uniqueElement => {
                const subHistogramData = Array(headers.length - 2).fill(0); // Initialize data array for sub-histogram
                for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                    for (let colIndex = 2; colIndex < 11; colIndex++) {
                        if (rows[rowIndex][colIndex] === uniqueElement) {
                            subHistogramData[colIndex - 2] += 1; // Increment the count for this column
                        }
                    }
                }

                // Create a canvas element for the sub-histogram
                const canvasId = `subHistogram_${uniqueElement.replace(/\s+/g, '_')}`;
                const section = document.createElement('section');
                section.classList.add('chart-container');
                section.innerHTML = `<h2>${uniqueElement}</h2><canvas id="${canvasId}"></canvas>`;
                document.getElementById('chartsContainer').appendChild(section);

                // Extract contents within [] from headers.slice(2, 11)
                const xLabels_3_to_11 = headers.slice(2, 11).map(header => {
                    const startIndex = header.indexOf('[') + 1;
                    const endIndex = header.indexOf(']');
                    return header.substring(startIndex, endIndex);
                });

                // Create sub-histogram chart
                createChart(uniqueElement, xLabels_3_to_11, subHistogramData, canvasId, 'pie');
            });

        });
    </script>

</body>
</html>

